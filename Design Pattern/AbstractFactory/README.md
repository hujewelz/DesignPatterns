# 抽象工厂模式
**定义：**为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。<br>
**类型：**创建型模式。<br>
**类图** 

![类图](http://wiki.jikexueyuan.com/project/java-design-pattern/images/abstract-factory-pattern-1.gif)

## 抽象工厂模式与工厂方法模式的区别
抽象工厂模式是工厂方法模式的升级版本，他用来**创建一组相关或者相互依赖的对象**。他与工厂方法模式的区别就在于，*工厂方法模式针对的是一个产品等级结构*；而*抽象工厂模式则是针对的多个产品等级结构*。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，*工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类*，而*抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类*。

在抽象工厂模式中，有一个产品族的概念：*所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族*。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。拿生产智能手机和手表的例子来说明他们之间的区别。

![类图](https://github.com/hujewelz/DesignPatterns/blob/master/resource/abstractfac.png)

在上面的类图中，手机和手表称为两个不同的等级结构；而苹果手机和安卓手机则称为两个不同的产品族。具体一点，苹果手机和安卓手机属于同一个等级结构，苹果表和安卓表属于另一个等级结构；而苹果手机和苹果表属于同一个产品族，安卓手机和安卓表属于另一个产品族。

明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供苹果手机和安卓手机，那么他属于工厂方法模式；如果一个工厂模式是提供苹果手机和苹果表两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。
```swift
protocol Factory {
  func createPhone() -> Phone
  func createWatch() -> Watch
}

struct AppleFactory: Factory {
  func createPhone() -> Phone {
    return IPhone()
  }
  
  func createWatch() -> Watch {
    return IWatch()
  }
}

```
## 抽象工厂模式的优点
抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以*在类的内部对产品族进行约束*。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。

## 抽象工厂模式的缺点
产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。

## 适用场景
当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。
